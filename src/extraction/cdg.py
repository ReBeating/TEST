import networkx as nx
from typing import Dict, Set, List, Tuple

class CDGBuilder:
    def __init__(self, cfg: nx.DiGraph):
        self.cfg = cfg
        self.cdg = nx.DiGraph()
        # Copy all nodes to CDG (preserve ID and attributes)
        for node, data in cfg.nodes(data=True):
            self.cdg.add_node(node, **data)
            
    def build(self) -> nx.DiGraph:
        """
        Build Control Dependence Graph (CDG)
        """
        # 1. Get Entry and Exit
        # Note: Must ensure CFG has only one virtual EXIT node, and all paths eventually converge here
        exit_id = self.cfg.graph.get('exit')
        if not exit_id or exit_id not in self.cfg:
            raise ValueError("CFG must have a valid 'exit' node marked in graph['exit']")

        # 2. Build Reverse CFG
        # Post-Dominator on CFG == Dominator on Reverse CFG
        r_cfg = self.cfg.reverse()
        
        # 3. Calculate Post-Dominator Tree (PDT)
        # networkx.immediate_dominators returns dict: {node: dominator}
        # In r_cfg, start node is the exit of the original graph
        try:
            # If there is dead code (cannot reach EXIT), these nodes will not appear in pdoms
            pdoms = nx.immediate_dominators(r_cfg, exit_id)
        except Exception as e:
            print(f"[CDG] Error computing post-dominators: {e}")
            # Fallback: Compute only on subgraph reachable to exit
            reachable = nx.ancestors(self.cfg, exit_id)
            reachable.add(exit_id)
            sub_r_cfg = r_cfg.subgraph(reachable)
            pdoms = nx.immediate_dominators(sub_r_cfg, exit_id)

        # 4. Calculate Control Dependence
        # Iterate through every edge (A -> B) in CFG
        for u, v, data in self.cfg.edges(data=True):
            # Ignore nodes that cannot reach EXIT (Dead code has no defined control dependence)
            if u not in pdoms or v not in pdoms:
                continue
            
            # Definition: If v does not post-dominate u (i.e., v is not an ancestor of u in the PDT)
            # In PDT dict representation, pdoms[u] is u's parent
            # Check if v post-dominates u: Check if v appears on u's pdom chain
            # But there is a simpler algorithm (Ferrante et al.):
            
            # Algorithm Core:
            # For each edge (u, v), if v is not a strict post-dominator of u
            # Or more accurately: if v does not post-dominate u (i.e., u -> v is a critical edge causing flow bifurcation)
            # In practice, as long as it is a branch edge (TRUE/FALSE/SWITCH), v usually does not post-dominate u
            
            # We find the PDT path from v to ipdom(u) (excluding ipdom(u))
            # All nodes w on the path are control dependent nodes of u
            
            # Find u's Immediate Post-Dominator (IPDOM)
            u_ipdom = pdoms.get(u)
            
            # Cursor runner climbs up the PDT starting from v
            runner = v
            
            # Stop conditions:
            # 1. runner == u_ipdom (Reached convergence point)
            # 2. runner == None (Reached EXIT root node)
            # 3. Avoid infinite loops (PDT is a tree, shouldn't have loops)
            
            # Special case: Self-loop A->A. A depends on A. Here runner=A, u_ipdom=A's parent.
            # runner != u_ipdom holds, add A->A dependence.
            
            while runner != u_ipdom and runner is not None:
                # Add control dependence edge: u (Controller) -> runner (Dependent)
                # Edge attributes: Inherit attributes from CFG edge (e.g., 'TRUE' or 'FALSE')
                # This means: runner executes only when u takes that branch
                
                # Avoid duplicates (nx handles it, but for logic clarity)
                if not self.cdg.has_edge(u, runner):
                    label = data.get('type', 'FLOW')
                    # Only branch type edges make sense to mark True/False
                    if label in ('FLOW', 'BACK_EDGE', 'FALLTHROUGH'):
                        # For Loop Back Edge (Body -> Header), Body depends on Header (True)
                        # But conversely, does Header depend on Body? No.
                        # Usually we only care about dependencies generated by PREDICATES
                        label = 'CONTROL' 
                    
                    self.cdg.add_edge(u, runner, type=label)
                
                # Climb up PDT
                if runner == exit_id:
                    break # Reached root node
                runner = pdoms.get(runner)

        return self.cdg